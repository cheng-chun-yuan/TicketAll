{
  "version": 3,
  "sources": ["../../@passwordlessdev/passwordless-client/src/passwordless.ts"],
  "sourcesContent": ["import {\n    AtLeast,\n    PromiseResult,\n    RegisterBeginResponse,    \n    SigninBeginResponse,\n    SigninMethod,\n    TokenResponse\n} from './types';\n\nexport interface Config {\n    apiUrl: string;\n    apiKey: string;\n    origin: string;\n    rpid: string;\n}\n\nexport class Client {\n    private config: Config = {\n        apiUrl: 'https://v4.passwordless.dev',\n        apiKey: '',\n        origin: window.location.origin,\n        rpid: window.location.hostname,\n    }\n    private abortController: AbortController = new AbortController();\n\n    constructor(config: AtLeast<Config, 'apiKey'>) {\n        Object.assign(this.config, config);\n    }\n\n    /**\n     * Register a new credential to a user\n     *\n     * @param {string} token Token generated by your backend and the Passwordless API\n     */\n    public async register(token: string, credentialNickname: string): PromiseResult<TokenResponse> {\n        try {            \n            this.assertBrowserSupported();\n            \n            const registration = await this.registerBegin(token);\n            if(registration.error) {\n                console.error(registration.error);\n                return { error: registration.error}                \n            }\n\n            registration.data.challenge = base64UrlToArrayBuffer(registration.data.challenge);\n            registration.data.user.id = base64UrlToArrayBuffer(registration.data.user.id);\n            registration.data.excludeCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.create({\n                publicKey: registration.data,\n            }) as PublicKeyCredential;\n\n            if (!credential) {\n                const error = {\n                    from: \"client\",\n                    errorCode: \"failed_create_credential\",\n                    title: \"Failed to create credential (navigator.credentials.create returned null)\",\n                };\n                console.error(error);\n                return { error };\n            }\n\n            return await this.registerComplete(credential, registration.session, credentialNickname);\n            \n            // next steps\n            // return a token from the API\n            // Add a type to the token (method/action)\n            \n        } catch (caughtError: any) {\n            \n            const errorMessage = getErrorMessage(caughtError);                            \n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n            \n            return { error };\n        }\n    }\n\n    /**\n     * Sign in a user using the userid\n     * @param {string} userId\n     * @returns\n     */\n    public async signinWithId(userId: string): PromiseResult<TokenResponse> {\n        return this.signin({userId})\n    }\n\n    \n\n    /**\n     * Sign in a user using an alias\n     * @param {string} alias\n     * @returns a verify_token\n     */\n    public async signinWithAlias(alias: string): PromiseResult<TokenResponse> {\n        return this.signin({alias})\n    }\n\n    /**\n     * Sign in a user using autofill UI (a.k.a conditional) sign in\n     * @returns a verify_token\n     */\n    public async signinWithAutofill(): PromiseResult<TokenResponse> {\n        if (!await isAutofillSupported()) {\n            throw new Error(\"Autofill authentication (conditional meditation) is not supported in this browser\");\n        }\n        return this.signin({autofill: true});\n    }\n\n    /**\n     * Sign in a user using discoverable credentials     \n     * @returns a verify_token\n     */\n    public async signinWithDiscoverable(): PromiseResult<TokenResponse> {\n        return this.signin({discoverable: true});\n    }\n\n    public abort() {\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n    }\n\n    public isPlatformSupported(): Promise<boolean> {\n        return isPlatformSupported();\n    }\n\n    public isBrowserSupported(): boolean {\n        return isBrowserSupported();\n    }\n\n    public isAutofillSupported(): Promise<boolean> {\n        return isAutofillSupported();\n    }\n\n    private async registerBegin(token: string): PromiseResult<RegisterBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/register/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                token,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async registerComplete(\n        credential: PublicKeyCredential,\n        session: string,\n        credentialNickname: string,\n    ): PromiseResult<TokenResponse> {\n        const attestationResponse = credential.response as AuthenticatorAttestationResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/register/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(credential.rawId),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        AttestationObject: arrayBufferToBase64Url(\n                            attestationResponse.attestationObject\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            attestationResponse.clientDataJSON\n                        ),\n                    },\n                },\n                nickname: credentialNickname,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    /**\n     * Sign in a user\n     *\n     * @param {SigninMethod} Object containing either UserID or Alias\n     * @returns\n     */\n    private async signin(signinMethod: SigninMethod): PromiseResult<TokenResponse> {\n        try {\n            this.assertBrowserSupported();\n            this.handleAbort();\n            \n            // if signinMethod is undefined, set it to an empty object\n            // this will cause a login using discoverable credentials\n            if(!signinMethod) {\n                signinMethod = { discoverable: true };\n            }            \n                    \n            const signin = await this.signinBegin(signinMethod);\n            if(signin.error) {\n                return signin;\n            }\n\n            signin.data.challenge = base64UrlToArrayBuffer(signin.data.challenge);\n            signin.data.allowCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.get({\n                publicKey: signin.data,\n                mediation: 'autofill' in signinMethod ? \"conditional\" as CredentialMediationRequirement : undefined, // Typescript doesn't know about 'conditational' yet\n                signal: this.abortController.signal,\n            }) as PublicKeyCredential;\n\n            const response = await this.signinComplete(credential, signin.session);\n            return response;\n            \n        } catch (caughtError: any) {           \n            const errorMessage = getErrorMessage(caughtError);\n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n\n            return { error };\n        }\n    }\n\n    private async signinBegin(signinMethod: SigninMethod): PromiseResult<SigninBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/signin/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                userId: \"userId\" in signinMethod ? signinMethod.userId : undefined,\n                alias: \"alias\" in signinMethod ? signinMethod.alias : undefined,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async signinComplete(\n        credential: PublicKeyCredential,\n        session: string,\n    ): PromiseResult<TokenResponse> {\n        const assertionResponse = credential.response as AuthenticatorAssertionResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/signin/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(new Uint8Array(credential.rawId)),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        authenticatorData: arrayBufferToBase64Url(\n                            assertionResponse.authenticatorData,\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            assertionResponse.clientDataJSON\n                        ),\n                        signature: arrayBufferToBase64Url(\n                            assertionResponse.signature\n                        ),\n                    },\n                },\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private handleAbort() {\n        this.abort();\n        this.abortController = new AbortController();\n    }\n\n    private assertBrowserSupported(): void {\n        if (!isBrowserSupported()) {\n            throw new Error('WebAuthn and PublicKeyCredentials are not supported on this browser/device');\n        }\n    }\n\n    private createHeaders(): Record<string, string> {\n        return {\n            ApiKey: this.config.apiKey,\n            'Content-Type': 'application/json',\n            'Client-Version': 'js-1.1.0'\n        };\n    }\n}\n\nexport async function isPlatformSupported(): Promise<boolean> {\n    if (!isBrowserSupported()) return false;\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport function isBrowserSupported(): boolean {\n    return window.PublicKeyCredential !== undefined && typeof window.PublicKeyCredential === 'function';\n}\n\nexport async function isAutofillSupported(): Promise<boolean> {\n    const PublicKeyCredential = window.PublicKeyCredential as any; // Typescript lacks support for this\n    if (!PublicKeyCredential.isConditionalMediationAvailable) return false;\n    return PublicKeyCredential.isConditionalMediationAvailable() as Promise<boolean>;\n}\n\nfunction base64ToBase64Url(base64: string): string {\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=*$/g, '');\n}\n\nfunction base64UrlToBase64(base64Url: string): string {\n    return base64Url.replace(/-/g, '+').replace(/_/g, '/');\n}\n\nfunction base64UrlToArrayBuffer(base64UrlString: string | BufferSource): ArrayBuffer {\n    // improvement: Remove BufferSource-type and add proper types upstream\n    if (typeof base64UrlString !== 'string') {\n        const msg = \"Cannot convert from Base64Url to ArrayBuffer: Input was not of type string\";\n        console.error(msg, base64UrlString);\n        throw new TypeError(msg);\n    }\n\n    const base64Unpadded = base64UrlToBase64(base64UrlString);\n    const paddingNeeded = (4 - (base64Unpadded.length % 4)) % 4;\n    const base64Padded = base64Unpadded.padEnd(base64Unpadded.length + paddingNeeded, \"=\");\n\n    const binary = window.atob(base64Padded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n\n    return bytes;\n}\n\nfunction arrayBufferToBase64Url(buffer: ArrayBuffer | Uint8Array): string {\n    const uint8Array = (() => {\n        if (Array.isArray(buffer)) return Uint8Array.from(buffer);\n        if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);\n        if (buffer instanceof Uint8Array) return buffer;\n\n        const msg = \"Cannot convert from ArrayBuffer to Base64Url. Input was not of type ArrayBuffer, Uint8Array or Array\";\n        console.error(msg, buffer);\n        throw new Error(msg);\n    })();\n\n    let string = '';\n    for (let i = 0; i < uint8Array.byteLength; i++) {\n        string += String.fromCharCode(uint8Array[i]);\n    }\n\n    const base64String = window.btoa(string);\n    return base64ToBase64Url(base64String);\n}\n\ntype ErrorWithMessage = {\n    message: string\n}\n\nfunction isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n    return (\n        typeof error === 'object' &&\n        error !== null &&\n        'message' in error &&\n        typeof (error as Record<string, unknown>).message === 'string'\n    )\n}\n\nfunction toErrorWithMessage(maybeError: unknown): ErrorWithMessage {\n    if (isErrorWithMessage(maybeError)) return maybeError\n\n    try {\n        return new Error(JSON.stringify(maybeError))\n    } catch {\n        // fallback in case there's an error stringifying the maybeError\n        // like with circular references for example.\n        return new Error(String(maybeError))\n    }\n}\n\nfunction getErrorMessage(error: unknown) {\n    return toErrorWithMessage(error).message\n}"],
  "mappings": "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",
  "names": ["PublicKeyCredential"]
}
