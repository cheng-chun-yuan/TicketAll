{"version":3,"file":"passwordless.min.mjs","sources":["../../src/passwordless.ts"],"sourcesContent":["import {\n    AtLeast,\n    PromiseResult,\n    RegisterBeginResponse,    \n    SigninBeginResponse,\n    SigninMethod,\n    TokenResponse\n} from './types';\n\nexport interface Config {\n    apiUrl: string;\n    apiKey: string;\n    origin: string;\n    rpid: string;\n}\n\nexport class Client {\n    private config: Config = {\n        apiUrl: 'https://v4.passwordless.dev',\n        apiKey: '',\n        origin: window.location.origin,\n        rpid: window.location.hostname,\n    }\n    private abortController: AbortController = new AbortController();\n\n    constructor(config: AtLeast<Config, 'apiKey'>) {\n        Object.assign(this.config, config);\n    }\n\n    /**\n     * Register a new credential to a user\n     *\n     * @param {string} token Token generated by your backend and the Passwordless API\n     */\n    public async register(token: string, credentialNickname: string): PromiseResult<TokenResponse> {\n        try {            \n            this.assertBrowserSupported();\n            \n            const registration = await this.registerBegin(token);\n            if(registration.error) {\n                console.error(registration.error);\n                return { error: registration.error}                \n            }\n\n            registration.data.challenge = base64UrlToArrayBuffer(registration.data.challenge);\n            registration.data.user.id = base64UrlToArrayBuffer(registration.data.user.id);\n            registration.data.excludeCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.create({\n                publicKey: registration.data,\n            }) as PublicKeyCredential;\n\n            if (!credential) {\n                const error = {\n                    from: \"client\",\n                    errorCode: \"failed_create_credential\",\n                    title: \"Failed to create credential (navigator.credentials.create returned null)\",\n                };\n                console.error(error);\n                return { error };\n            }\n\n            return await this.registerComplete(credential, registration.session, credentialNickname);\n            \n            // next steps\n            // return a token from the API\n            // Add a type to the token (method/action)\n            \n        } catch (caughtError: any) {\n            \n            const errorMessage = getErrorMessage(caughtError);                            \n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n            \n            return { error };\n        }\n    }\n\n    /**\n     * Sign in a user using the userid\n     * @param {string} userId\n     * @returns\n     */\n    public async signinWithId(userId: string): PromiseResult<TokenResponse> {\n        return this.signin({userId})\n    }\n\n    \n\n    /**\n     * Sign in a user using an alias\n     * @param {string} alias\n     * @returns a verify_token\n     */\n    public async signinWithAlias(alias: string): PromiseResult<TokenResponse> {\n        return this.signin({alias})\n    }\n\n    /**\n     * Sign in a user using autofill UI (a.k.a conditional) sign in\n     * @returns a verify_token\n     */\n    public async signinWithAutofill(): PromiseResult<TokenResponse> {\n        if (!await isAutofillSupported()) {\n            throw new Error(\"Autofill authentication (conditional meditation) is not supported in this browser\");\n        }\n        return this.signin({autofill: true});\n    }\n\n    /**\n     * Sign in a user using discoverable credentials     \n     * @returns a verify_token\n     */\n    public async signinWithDiscoverable(): PromiseResult<TokenResponse> {\n        return this.signin({discoverable: true});\n    }\n\n    public abort() {\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n    }\n\n    public isPlatformSupported(): Promise<boolean> {\n        return isPlatformSupported();\n    }\n\n    public isBrowserSupported(): boolean {\n        return isBrowserSupported();\n    }\n\n    public isAutofillSupported(): Promise<boolean> {\n        return isAutofillSupported();\n    }\n\n    private async registerBegin(token: string): PromiseResult<RegisterBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/register/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                token,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async registerComplete(\n        credential: PublicKeyCredential,\n        session: string,\n        credentialNickname: string,\n    ): PromiseResult<TokenResponse> {\n        const attestationResponse = credential.response as AuthenticatorAttestationResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/register/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(credential.rawId),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        AttestationObject: arrayBufferToBase64Url(\n                            attestationResponse.attestationObject\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            attestationResponse.clientDataJSON\n                        ),\n                    },\n                },\n                nickname: credentialNickname,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    /**\n     * Sign in a user\n     *\n     * @param {SigninMethod} Object containing either UserID or Alias\n     * @returns\n     */\n    private async signin(signinMethod: SigninMethod): PromiseResult<TokenResponse> {\n        try {\n            this.assertBrowserSupported();\n            this.handleAbort();\n            \n            // if signinMethod is undefined, set it to an empty object\n            // this will cause a login using discoverable credentials\n            if(!signinMethod) {\n                signinMethod = { discoverable: true };\n            }            \n                    \n            const signin = await this.signinBegin(signinMethod);\n            if(signin.error) {\n                return signin;\n            }\n\n            signin.data.challenge = base64UrlToArrayBuffer(signin.data.challenge);\n            signin.data.allowCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.get({\n                publicKey: signin.data,\n                mediation: 'autofill' in signinMethod ? \"conditional\" as CredentialMediationRequirement : undefined, // Typescript doesn't know about 'conditational' yet\n                signal: this.abortController.signal,\n            }) as PublicKeyCredential;\n\n            const response = await this.signinComplete(credential, signin.session);\n            return response;\n            \n        } catch (caughtError: any) {           \n            const errorMessage = getErrorMessage(caughtError);\n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n\n            return { error };\n        }\n    }\n\n    private async signinBegin(signinMethod: SigninMethod): PromiseResult<SigninBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/signin/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                userId: \"userId\" in signinMethod ? signinMethod.userId : undefined,\n                alias: \"alias\" in signinMethod ? signinMethod.alias : undefined,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async signinComplete(\n        credential: PublicKeyCredential,\n        session: string,\n    ): PromiseResult<TokenResponse> {\n        const assertionResponse = credential.response as AuthenticatorAssertionResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/signin/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(new Uint8Array(credential.rawId)),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        authenticatorData: arrayBufferToBase64Url(\n                            assertionResponse.authenticatorData,\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            assertionResponse.clientDataJSON\n                        ),\n                        signature: arrayBufferToBase64Url(\n                            assertionResponse.signature\n                        ),\n                    },\n                },\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private handleAbort() {\n        this.abort();\n        this.abortController = new AbortController();\n    }\n\n    private assertBrowserSupported(): void {\n        if (!isBrowserSupported()) {\n            throw new Error('WebAuthn and PublicKeyCredentials are not supported on this browser/device');\n        }\n    }\n\n    private createHeaders(): Record<string, string> {\n        return {\n            ApiKey: this.config.apiKey,\n            'Content-Type': 'application/json',\n            'Client-Version': 'js-1.1.0'\n        };\n    }\n}\n\nexport async function isPlatformSupported(): Promise<boolean> {\n    if (!isBrowserSupported()) return false;\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport function isBrowserSupported(): boolean {\n    return window.PublicKeyCredential !== undefined && typeof window.PublicKeyCredential === 'function';\n}\n\nexport async function isAutofillSupported(): Promise<boolean> {\n    const PublicKeyCredential = window.PublicKeyCredential as any; // Typescript lacks support for this\n    if (!PublicKeyCredential.isConditionalMediationAvailable) return false;\n    return PublicKeyCredential.isConditionalMediationAvailable() as Promise<boolean>;\n}\n\nfunction base64ToBase64Url(base64: string): string {\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=*$/g, '');\n}\n\nfunction base64UrlToBase64(base64Url: string): string {\n    return base64Url.replace(/-/g, '+').replace(/_/g, '/');\n}\n\nfunction base64UrlToArrayBuffer(base64UrlString: string | BufferSource): ArrayBuffer {\n    // improvement: Remove BufferSource-type and add proper types upstream\n    if (typeof base64UrlString !== 'string') {\n        const msg = \"Cannot convert from Base64Url to ArrayBuffer: Input was not of type string\";\n        console.error(msg, base64UrlString);\n        throw new TypeError(msg);\n    }\n\n    const base64Unpadded = base64UrlToBase64(base64UrlString);\n    const paddingNeeded = (4 - (base64Unpadded.length % 4)) % 4;\n    const base64Padded = base64Unpadded.padEnd(base64Unpadded.length + paddingNeeded, \"=\");\n\n    const binary = window.atob(base64Padded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n\n    return bytes;\n}\n\nfunction arrayBufferToBase64Url(buffer: ArrayBuffer | Uint8Array): string {\n    const uint8Array = (() => {\n        if (Array.isArray(buffer)) return Uint8Array.from(buffer);\n        if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);\n        if (buffer instanceof Uint8Array) return buffer;\n\n        const msg = \"Cannot convert from ArrayBuffer to Base64Url. Input was not of type ArrayBuffer, Uint8Array or Array\";\n        console.error(msg, buffer);\n        throw new Error(msg);\n    })();\n\n    let string = '';\n    for (let i = 0; i < uint8Array.byteLength; i++) {\n        string += String.fromCharCode(uint8Array[i]);\n    }\n\n    const base64String = window.btoa(string);\n    return base64ToBase64Url(base64String);\n}\n\ntype ErrorWithMessage = {\n    message: string\n}\n\nfunction isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n    return (\n        typeof error === 'object' &&\n        error !== null &&\n        'message' in error &&\n        typeof (error as Record<string, unknown>).message === 'string'\n    )\n}\n\nfunction toErrorWithMessage(maybeError: unknown): ErrorWithMessage {\n    if (isErrorWithMessage(maybeError)) return maybeError\n\n    try {\n        return new Error(JSON.stringify(maybeError))\n    } catch {\n        // fallback in case there's an error stringifying the maybeError\n        // like with circular references for example.\n        return new Error(String(maybeError))\n    }\n}\n\nfunction getErrorMessage(error: unknown) {\n    return toErrorWithMessage(error).message\n}"],"names":["Client","constructor","config","this","apiUrl","apiKey","origin","window","location","rpid","hostname","AbortController","Object","assign","register","token","credentialNickname","assertBrowserSupported","registration","registerBegin","error","console","data","challenge","base64UrlToArrayBuffer","user","id","excludeCredentials","forEach","cred","credential","navigator","credentials","create","publicKey","from","errorCode","title","registerComplete","session","caughtError","getErrorMessage","signinWithId","userId","signin","signinWithAlias","alias","signinWithAutofill","isAutofillSupported","Error","autofill","signinWithDiscoverable","discoverable","abort","abortController","isPlatformSupported","isBrowserSupported","response","fetch","method","headers","createHeaders","body","JSON","stringify","RPID","Origin","res","json","ok","attestationResponse","rawId","arrayBufferToBase64Url","type","extensions","getClientExtensionResults","AttestationObject","attestationObject","clientDataJson","clientDataJSON","nickname","signinMethod","handleAbort","signinBegin","allowCredentials","get","mediation","undefined","signal","signinComplete","assertionResponse","Uint8Array","authenticatorData","signature","ApiKey","async","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","isConditionalMediationAvailable","base64UrlString","msg","TypeError","base64Unpadded","replace","paddingNeeded","length","base64Padded","padEnd","binary","atob","bytes","i","charCodeAt","buffer","uint8Array","Array","isArray","ArrayBuffer","string","byteLength","String","fromCharCode","base64String","btoa","maybeError","message","toErrorWithMessage"],"mappings":"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"}