{"version":3,"file":"passwordless.mjs","sources":["../../src/passwordless.ts"],"sourcesContent":["import {\n    AtLeast,\n    PromiseResult,\n    RegisterBeginResponse,    \n    SigninBeginResponse,\n    SigninMethod,\n    TokenResponse\n} from './types';\n\nexport interface Config {\n    apiUrl: string;\n    apiKey: string;\n    origin: string;\n    rpid: string;\n}\n\nexport class Client {\n    private config: Config = {\n        apiUrl: 'https://v4.passwordless.dev',\n        apiKey: '',\n        origin: window.location.origin,\n        rpid: window.location.hostname,\n    }\n    private abortController: AbortController = new AbortController();\n\n    constructor(config: AtLeast<Config, 'apiKey'>) {\n        Object.assign(this.config, config);\n    }\n\n    /**\n     * Register a new credential to a user\n     *\n     * @param {string} token Token generated by your backend and the Passwordless API\n     */\n    public async register(token: string, credentialNickname: string): PromiseResult<TokenResponse> {\n        try {            \n            this.assertBrowserSupported();\n            \n            const registration = await this.registerBegin(token);\n            if(registration.error) {\n                console.error(registration.error);\n                return { error: registration.error}                \n            }\n\n            registration.data.challenge = base64UrlToArrayBuffer(registration.data.challenge);\n            registration.data.user.id = base64UrlToArrayBuffer(registration.data.user.id);\n            registration.data.excludeCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.create({\n                publicKey: registration.data,\n            }) as PublicKeyCredential;\n\n            if (!credential) {\n                const error = {\n                    from: \"client\",\n                    errorCode: \"failed_create_credential\",\n                    title: \"Failed to create credential (navigator.credentials.create returned null)\",\n                };\n                console.error(error);\n                return { error };\n            }\n\n            return await this.registerComplete(credential, registration.session, credentialNickname);\n            \n            // next steps\n            // return a token from the API\n            // Add a type to the token (method/action)\n            \n        } catch (caughtError: any) {\n            \n            const errorMessage = getErrorMessage(caughtError);                            \n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n            \n            return { error };\n        }\n    }\n\n    /**\n     * Sign in a user using the userid\n     * @param {string} userId\n     * @returns\n     */\n    public async signinWithId(userId: string): PromiseResult<TokenResponse> {\n        return this.signin({userId})\n    }\n\n    \n\n    /**\n     * Sign in a user using an alias\n     * @param {string} alias\n     * @returns a verify_token\n     */\n    public async signinWithAlias(alias: string): PromiseResult<TokenResponse> {\n        return this.signin({alias})\n    }\n\n    /**\n     * Sign in a user using autofill UI (a.k.a conditional) sign in\n     * @returns a verify_token\n     */\n    public async signinWithAutofill(): PromiseResult<TokenResponse> {\n        if (!await isAutofillSupported()) {\n            throw new Error(\"Autofill authentication (conditional meditation) is not supported in this browser\");\n        }\n        return this.signin({autofill: true});\n    }\n\n    /**\n     * Sign in a user using discoverable credentials     \n     * @returns a verify_token\n     */\n    public async signinWithDiscoverable(): PromiseResult<TokenResponse> {\n        return this.signin({discoverable: true});\n    }\n\n    public abort() {\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n    }\n\n    public isPlatformSupported(): Promise<boolean> {\n        return isPlatformSupported();\n    }\n\n    public isBrowserSupported(): boolean {\n        return isBrowserSupported();\n    }\n\n    public isAutofillSupported(): Promise<boolean> {\n        return isAutofillSupported();\n    }\n\n    private async registerBegin(token: string): PromiseResult<RegisterBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/register/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                token,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async registerComplete(\n        credential: PublicKeyCredential,\n        session: string,\n        credentialNickname: string,\n    ): PromiseResult<TokenResponse> {\n        const attestationResponse = credential.response as AuthenticatorAttestationResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/register/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(credential.rawId),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        AttestationObject: arrayBufferToBase64Url(\n                            attestationResponse.attestationObject\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            attestationResponse.clientDataJSON\n                        ),\n                    },\n                },\n                nickname: credentialNickname,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    /**\n     * Sign in a user\n     *\n     * @param {SigninMethod} Object containing either UserID or Alias\n     * @returns\n     */\n    private async signin(signinMethod: SigninMethod): PromiseResult<TokenResponse> {\n        try {\n            this.assertBrowserSupported();\n            this.handleAbort();\n            \n            // if signinMethod is undefined, set it to an empty object\n            // this will cause a login using discoverable credentials\n            if(!signinMethod) {\n                signinMethod = { discoverable: true };\n            }            \n                    \n            const signin = await this.signinBegin(signinMethod);\n            if(signin.error) {\n                return signin;\n            }\n\n            signin.data.challenge = base64UrlToArrayBuffer(signin.data.challenge);\n            signin.data.allowCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.get({\n                publicKey: signin.data,\n                mediation: 'autofill' in signinMethod ? \"conditional\" as CredentialMediationRequirement : undefined, // Typescript doesn't know about 'conditational' yet\n                signal: this.abortController.signal,\n            }) as PublicKeyCredential;\n\n            const response = await this.signinComplete(credential, signin.session);\n            return response;\n            \n        } catch (caughtError: any) {           \n            const errorMessage = getErrorMessage(caughtError);\n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n\n            return { error };\n        }\n    }\n\n    private async signinBegin(signinMethod: SigninMethod): PromiseResult<SigninBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/signin/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                userId: \"userId\" in signinMethod ? signinMethod.userId : undefined,\n                alias: \"alias\" in signinMethod ? signinMethod.alias : undefined,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async signinComplete(\n        credential: PublicKeyCredential,\n        session: string,\n    ): PromiseResult<TokenResponse> {\n        const assertionResponse = credential.response as AuthenticatorAssertionResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/signin/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(new Uint8Array(credential.rawId)),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        authenticatorData: arrayBufferToBase64Url(\n                            assertionResponse.authenticatorData,\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            assertionResponse.clientDataJSON\n                        ),\n                        signature: arrayBufferToBase64Url(\n                            assertionResponse.signature\n                        ),\n                    },\n                },\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private handleAbort() {\n        this.abort();\n        this.abortController = new AbortController();\n    }\n\n    private assertBrowserSupported(): void {\n        if (!isBrowserSupported()) {\n            throw new Error('WebAuthn and PublicKeyCredentials are not supported on this browser/device');\n        }\n    }\n\n    private createHeaders(): Record<string, string> {\n        return {\n            ApiKey: this.config.apiKey,\n            'Content-Type': 'application/json',\n            'Client-Version': 'js-1.1.0'\n        };\n    }\n}\n\nexport async function isPlatformSupported(): Promise<boolean> {\n    if (!isBrowserSupported()) return false;\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport function isBrowserSupported(): boolean {\n    return window.PublicKeyCredential !== undefined && typeof window.PublicKeyCredential === 'function';\n}\n\nexport async function isAutofillSupported(): Promise<boolean> {\n    const PublicKeyCredential = window.PublicKeyCredential as any; // Typescript lacks support for this\n    if (!PublicKeyCredential.isConditionalMediationAvailable) return false;\n    return PublicKeyCredential.isConditionalMediationAvailable() as Promise<boolean>;\n}\n\nfunction base64ToBase64Url(base64: string): string {\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=*$/g, '');\n}\n\nfunction base64UrlToBase64(base64Url: string): string {\n    return base64Url.replace(/-/g, '+').replace(/_/g, '/');\n}\n\nfunction base64UrlToArrayBuffer(base64UrlString: string | BufferSource): ArrayBuffer {\n    // improvement: Remove BufferSource-type and add proper types upstream\n    if (typeof base64UrlString !== 'string') {\n        const msg = \"Cannot convert from Base64Url to ArrayBuffer: Input was not of type string\";\n        console.error(msg, base64UrlString);\n        throw new TypeError(msg);\n    }\n\n    const base64Unpadded = base64UrlToBase64(base64UrlString);\n    const paddingNeeded = (4 - (base64Unpadded.length % 4)) % 4;\n    const base64Padded = base64Unpadded.padEnd(base64Unpadded.length + paddingNeeded, \"=\");\n\n    const binary = window.atob(base64Padded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n\n    return bytes;\n}\n\nfunction arrayBufferToBase64Url(buffer: ArrayBuffer | Uint8Array): string {\n    const uint8Array = (() => {\n        if (Array.isArray(buffer)) return Uint8Array.from(buffer);\n        if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);\n        if (buffer instanceof Uint8Array) return buffer;\n\n        const msg = \"Cannot convert from ArrayBuffer to Base64Url. Input was not of type ArrayBuffer, Uint8Array or Array\";\n        console.error(msg, buffer);\n        throw new Error(msg);\n    })();\n\n    let string = '';\n    for (let i = 0; i < uint8Array.byteLength; i++) {\n        string += String.fromCharCode(uint8Array[i]);\n    }\n\n    const base64String = window.btoa(string);\n    return base64ToBase64Url(base64String);\n}\n\ntype ErrorWithMessage = {\n    message: string\n}\n\nfunction isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n    return (\n        typeof error === 'object' &&\n        error !== null &&\n        'message' in error &&\n        typeof (error as Record<string, unknown>).message === 'string'\n    )\n}\n\nfunction toErrorWithMessage(maybeError: unknown): ErrorWithMessage {\n    if (isErrorWithMessage(maybeError)) return maybeError\n\n    try {\n        return new Error(JSON.stringify(maybeError))\n    } catch {\n        // fallback in case there's an error stringifying the maybeError\n        // like with circular references for example.\n        return new Error(String(maybeError))\n    }\n}\n\nfunction getErrorMessage(error: unknown) {\n    return toErrorWithMessage(error).message\n}"],"names":[],"mappings":"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"}