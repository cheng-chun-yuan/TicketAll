{"version":3,"file":"passwordless.iife.min.js","sources":["../../src/passwordless.ts"],"sourcesContent":["import {\n    AtLeast,\n    PromiseResult,\n    RegisterBeginResponse,    \n    SigninBeginResponse,\n    SigninMethod,\n    TokenResponse\n} from './types';\n\nexport interface Config {\n    apiUrl: string;\n    apiKey: string;\n    origin: string;\n    rpid: string;\n}\n\nexport class Client {\n    private config: Config = {\n        apiUrl: 'https://v4.passwordless.dev',\n        apiKey: '',\n        origin: window.location.origin,\n        rpid: window.location.hostname,\n    }\n    private abortController: AbortController = new AbortController();\n\n    constructor(config: AtLeast<Config, 'apiKey'>) {\n        Object.assign(this.config, config);\n    }\n\n    /**\n     * Register a new credential to a user\n     *\n     * @param {string} token Token generated by your backend and the Passwordless API\n     */\n    public async register(token: string, credentialNickname: string): PromiseResult<TokenResponse> {\n        try {            \n            this.assertBrowserSupported();\n            \n            const registration = await this.registerBegin(token);\n            if(registration.error) {\n                console.error(registration.error);\n                return { error: registration.error}                \n            }\n\n            registration.data.challenge = base64UrlToArrayBuffer(registration.data.challenge);\n            registration.data.user.id = base64UrlToArrayBuffer(registration.data.user.id);\n            registration.data.excludeCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.create({\n                publicKey: registration.data,\n            }) as PublicKeyCredential;\n\n            if (!credential) {\n                const error = {\n                    from: \"client\",\n                    errorCode: \"failed_create_credential\",\n                    title: \"Failed to create credential (navigator.credentials.create returned null)\",\n                };\n                console.error(error);\n                return { error };\n            }\n\n            return await this.registerComplete(credential, registration.session, credentialNickname);\n            \n            // next steps\n            // return a token from the API\n            // Add a type to the token (method/action)\n            \n        } catch (caughtError: any) {\n            \n            const errorMessage = getErrorMessage(caughtError);                            \n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n            \n            return { error };\n        }\n    }\n\n    /**\n     * Sign in a user using the userid\n     * @param {string} userId\n     * @returns\n     */\n    public async signinWithId(userId: string): PromiseResult<TokenResponse> {\n        return this.signin({userId})\n    }\n\n    \n\n    /**\n     * Sign in a user using an alias\n     * @param {string} alias\n     * @returns a verify_token\n     */\n    public async signinWithAlias(alias: string): PromiseResult<TokenResponse> {\n        return this.signin({alias})\n    }\n\n    /**\n     * Sign in a user using autofill UI (a.k.a conditional) sign in\n     * @returns a verify_token\n     */\n    public async signinWithAutofill(): PromiseResult<TokenResponse> {\n        if (!await isAutofillSupported()) {\n            throw new Error(\"Autofill authentication (conditional meditation) is not supported in this browser\");\n        }\n        return this.signin({autofill: true});\n    }\n\n    /**\n     * Sign in a user using discoverable credentials     \n     * @returns a verify_token\n     */\n    public async signinWithDiscoverable(): PromiseResult<TokenResponse> {\n        return this.signin({discoverable: true});\n    }\n\n    public abort() {\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n    }\n\n    public isPlatformSupported(): Promise<boolean> {\n        return isPlatformSupported();\n    }\n\n    public isBrowserSupported(): boolean {\n        return isBrowserSupported();\n    }\n\n    public isAutofillSupported(): Promise<boolean> {\n        return isAutofillSupported();\n    }\n\n    private async registerBegin(token: string): PromiseResult<RegisterBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/register/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                token,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async registerComplete(\n        credential: PublicKeyCredential,\n        session: string,\n        credentialNickname: string,\n    ): PromiseResult<TokenResponse> {\n        const attestationResponse = credential.response as AuthenticatorAttestationResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/register/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(credential.rawId),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        AttestationObject: arrayBufferToBase64Url(\n                            attestationResponse.attestationObject\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            attestationResponse.clientDataJSON\n                        ),\n                    },\n                },\n                nickname: credentialNickname,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    /**\n     * Sign in a user\n     *\n     * @param {SigninMethod} Object containing either UserID or Alias\n     * @returns\n     */\n    private async signin(signinMethod: SigninMethod): PromiseResult<TokenResponse> {\n        try {\n            this.assertBrowserSupported();\n            this.handleAbort();\n            \n            // if signinMethod is undefined, set it to an empty object\n            // this will cause a login using discoverable credentials\n            if(!signinMethod) {\n                signinMethod = { discoverable: true };\n            }            \n                    \n            const signin = await this.signinBegin(signinMethod);\n            if(signin.error) {\n                return signin;\n            }\n\n            signin.data.challenge = base64UrlToArrayBuffer(signin.data.challenge);\n            signin.data.allowCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.get({\n                publicKey: signin.data,\n                mediation: 'autofill' in signinMethod ? \"conditional\" as CredentialMediationRequirement : undefined, // Typescript doesn't know about 'conditational' yet\n                signal: this.abortController.signal,\n            }) as PublicKeyCredential;\n\n            const response = await this.signinComplete(credential, signin.session);\n            return response;\n            \n        } catch (caughtError: any) {           \n            const errorMessage = getErrorMessage(caughtError);\n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n\n            return { error };\n        }\n    }\n\n    private async signinBegin(signinMethod: SigninMethod): PromiseResult<SigninBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/signin/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                userId: \"userId\" in signinMethod ? signinMethod.userId : undefined,\n                alias: \"alias\" in signinMethod ? signinMethod.alias : undefined,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async signinComplete(\n        credential: PublicKeyCredential,\n        session: string,\n    ): PromiseResult<TokenResponse> {\n        const assertionResponse = credential.response as AuthenticatorAssertionResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/signin/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(new Uint8Array(credential.rawId)),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        authenticatorData: arrayBufferToBase64Url(\n                            assertionResponse.authenticatorData,\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            assertionResponse.clientDataJSON\n                        ),\n                        signature: arrayBufferToBase64Url(\n                            assertionResponse.signature\n                        ),\n                    },\n                },\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private handleAbort() {\n        this.abort();\n        this.abortController = new AbortController();\n    }\n\n    private assertBrowserSupported(): void {\n        if (!isBrowserSupported()) {\n            throw new Error('WebAuthn and PublicKeyCredentials are not supported on this browser/device');\n        }\n    }\n\n    private createHeaders(): Record<string, string> {\n        return {\n            ApiKey: this.config.apiKey,\n            'Content-Type': 'application/json',\n            'Client-Version': 'js-1.1.0'\n        };\n    }\n}\n\nexport async function isPlatformSupported(): Promise<boolean> {\n    if (!isBrowserSupported()) return false;\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport function isBrowserSupported(): boolean {\n    return window.PublicKeyCredential !== undefined && typeof window.PublicKeyCredential === 'function';\n}\n\nexport async function isAutofillSupported(): Promise<boolean> {\n    const PublicKeyCredential = window.PublicKeyCredential as any; // Typescript lacks support for this\n    if (!PublicKeyCredential.isConditionalMediationAvailable) return false;\n    return PublicKeyCredential.isConditionalMediationAvailable() as Promise<boolean>;\n}\n\nfunction base64ToBase64Url(base64: string): string {\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=*$/g, '');\n}\n\nfunction base64UrlToBase64(base64Url: string): string {\n    return base64Url.replace(/-/g, '+').replace(/_/g, '/');\n}\n\nfunction base64UrlToArrayBuffer(base64UrlString: string | BufferSource): ArrayBuffer {\n    // improvement: Remove BufferSource-type and add proper types upstream\n    if (typeof base64UrlString !== 'string') {\n        const msg = \"Cannot convert from Base64Url to ArrayBuffer: Input was not of type string\";\n        console.error(msg, base64UrlString);\n        throw new TypeError(msg);\n    }\n\n    const base64Unpadded = base64UrlToBase64(base64UrlString);\n    const paddingNeeded = (4 - (base64Unpadded.length % 4)) % 4;\n    const base64Padded = base64Unpadded.padEnd(base64Unpadded.length + paddingNeeded, \"=\");\n\n    const binary = window.atob(base64Padded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n\n    return bytes;\n}\n\nfunction arrayBufferToBase64Url(buffer: ArrayBuffer | Uint8Array): string {\n    const uint8Array = (() => {\n        if (Array.isArray(buffer)) return Uint8Array.from(buffer);\n        if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);\n        if (buffer instanceof Uint8Array) return buffer;\n\n        const msg = \"Cannot convert from ArrayBuffer to Base64Url. Input was not of type ArrayBuffer, Uint8Array or Array\";\n        console.error(msg, buffer);\n        throw new Error(msg);\n    })();\n\n    let string = '';\n    for (let i = 0; i < uint8Array.byteLength; i++) {\n        string += String.fromCharCode(uint8Array[i]);\n    }\n\n    const base64String = window.btoa(string);\n    return base64ToBase64Url(base64String);\n}\n\ntype ErrorWithMessage = {\n    message: string\n}\n\nfunction isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n    return (\n        typeof error === 'object' &&\n        error !== null &&\n        'message' in error &&\n        typeof (error as Record<string, unknown>).message === 'string'\n    )\n}\n\nfunction toErrorWithMessage(maybeError: unknown): ErrorWithMessage {\n    if (isErrorWithMessage(maybeError)) return maybeError\n\n    try {\n        return new Error(JSON.stringify(maybeError))\n    } catch {\n        // fallback in case there's an error stringifying the maybeError\n        // like with circular references for example.\n        return new Error(String(maybeError))\n    }\n}\n\nfunction getErrorMessage(error: unknown) {\n    return toErrorWithMessage(error).message\n}"],"names":["async","isPlatformSupported","isBrowserSupported","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","undefined","window","isAutofillSupported","isConditionalMediationAvailable","base64UrlToArrayBuffer","base64UrlString","msg","console","error","TypeError","base64Unpadded","replace","paddingNeeded","length","base64Padded","padEnd","binary","atob","bytes","Uint8Array","i","charCodeAt","arrayBufferToBase64Url","buffer","uint8Array","Array","isArray","from","ArrayBuffer","Error","string","byteLength","String","fromCharCode","base64String","btoa","getErrorMessage","maybeError","message","JSON","stringify","toErrorWithMessage","constructor","config","this","apiUrl","apiKey","origin","location","rpid","hostname","AbortController","Object","assign","register","token","credentialNickname","assertBrowserSupported","registration","registerBegin","data","challenge","user","id","excludeCredentials","forEach","cred","credential","navigator","credentials","create","publicKey","errorCode","title","registerComplete","session","caughtError","signinWithId","userId","signin","signinWithAlias","alias","signinWithAutofill","autofill","signinWithDiscoverable","discoverable","abort","abortController","response","fetch","method","headers","createHeaders","body","RPID","Origin","res","json","ok","attestationResponse","rawId","type","extensions","getClientExtensionResults","AttestationObject","attestationObject","clientDataJson","clientDataJSON","nickname","signinMethod","handleAbort","signinBegin","allowCredentials","get","mediation","signal","signinComplete","assertionResponse","authenticatorData","signature","ApiKey"],"mappings":"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"}