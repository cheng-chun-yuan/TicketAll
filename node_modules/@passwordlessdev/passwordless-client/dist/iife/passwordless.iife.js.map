{"version":3,"file":"passwordless.iife.js","sources":["../../src/passwordless.ts"],"sourcesContent":["import {\n    AtLeast,\n    PromiseResult,\n    RegisterBeginResponse,    \n    SigninBeginResponse,\n    SigninMethod,\n    TokenResponse\n} from './types';\n\nexport interface Config {\n    apiUrl: string;\n    apiKey: string;\n    origin: string;\n    rpid: string;\n}\n\nexport class Client {\n    private config: Config = {\n        apiUrl: 'https://v4.passwordless.dev',\n        apiKey: '',\n        origin: window.location.origin,\n        rpid: window.location.hostname,\n    }\n    private abortController: AbortController = new AbortController();\n\n    constructor(config: AtLeast<Config, 'apiKey'>) {\n        Object.assign(this.config, config);\n    }\n\n    /**\n     * Register a new credential to a user\n     *\n     * @param {string} token Token generated by your backend and the Passwordless API\n     */\n    public async register(token: string, credentialNickname: string): PromiseResult<TokenResponse> {\n        try {            \n            this.assertBrowserSupported();\n            \n            const registration = await this.registerBegin(token);\n            if(registration.error) {\n                console.error(registration.error);\n                return { error: registration.error}                \n            }\n\n            registration.data.challenge = base64UrlToArrayBuffer(registration.data.challenge);\n            registration.data.user.id = base64UrlToArrayBuffer(registration.data.user.id);\n            registration.data.excludeCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.create({\n                publicKey: registration.data,\n            }) as PublicKeyCredential;\n\n            if (!credential) {\n                const error = {\n                    from: \"client\",\n                    errorCode: \"failed_create_credential\",\n                    title: \"Failed to create credential (navigator.credentials.create returned null)\",\n                };\n                console.error(error);\n                return { error };\n            }\n\n            return await this.registerComplete(credential, registration.session, credentialNickname);\n            \n            // next steps\n            // return a token from the API\n            // Add a type to the token (method/action)\n            \n        } catch (caughtError: any) {\n            \n            const errorMessage = getErrorMessage(caughtError);                            \n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n            \n            return { error };\n        }\n    }\n\n    /**\n     * Sign in a user using the userid\n     * @param {string} userId\n     * @returns\n     */\n    public async signinWithId(userId: string): PromiseResult<TokenResponse> {\n        return this.signin({userId})\n    }\n\n    \n\n    /**\n     * Sign in a user using an alias\n     * @param {string} alias\n     * @returns a verify_token\n     */\n    public async signinWithAlias(alias: string): PromiseResult<TokenResponse> {\n        return this.signin({alias})\n    }\n\n    /**\n     * Sign in a user using autofill UI (a.k.a conditional) sign in\n     * @returns a verify_token\n     */\n    public async signinWithAutofill(): PromiseResult<TokenResponse> {\n        if (!await isAutofillSupported()) {\n            throw new Error(\"Autofill authentication (conditional meditation) is not supported in this browser\");\n        }\n        return this.signin({autofill: true});\n    }\n\n    /**\n     * Sign in a user using discoverable credentials     \n     * @returns a verify_token\n     */\n    public async signinWithDiscoverable(): PromiseResult<TokenResponse> {\n        return this.signin({discoverable: true});\n    }\n\n    public abort() {\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n    }\n\n    public isPlatformSupported(): Promise<boolean> {\n        return isPlatformSupported();\n    }\n\n    public isBrowserSupported(): boolean {\n        return isBrowserSupported();\n    }\n\n    public isAutofillSupported(): Promise<boolean> {\n        return isAutofillSupported();\n    }\n\n    private async registerBegin(token: string): PromiseResult<RegisterBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/register/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                token,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async registerComplete(\n        credential: PublicKeyCredential,\n        session: string,\n        credentialNickname: string,\n    ): PromiseResult<TokenResponse> {\n        const attestationResponse = credential.response as AuthenticatorAttestationResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/register/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(credential.rawId),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        AttestationObject: arrayBufferToBase64Url(\n                            attestationResponse.attestationObject\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            attestationResponse.clientDataJSON\n                        ),\n                    },\n                },\n                nickname: credentialNickname,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    /**\n     * Sign in a user\n     *\n     * @param {SigninMethod} Object containing either UserID or Alias\n     * @returns\n     */\n    private async signin(signinMethod: SigninMethod): PromiseResult<TokenResponse> {\n        try {\n            this.assertBrowserSupported();\n            this.handleAbort();\n            \n            // if signinMethod is undefined, set it to an empty object\n            // this will cause a login using discoverable credentials\n            if(!signinMethod) {\n                signinMethod = { discoverable: true };\n            }            \n                    \n            const signin = await this.signinBegin(signinMethod);\n            if(signin.error) {\n                return signin;\n            }\n\n            signin.data.challenge = base64UrlToArrayBuffer(signin.data.challenge);\n            signin.data.allowCredentials?.forEach((cred) => {\n                cred.id = base64UrlToArrayBuffer(cred.id);\n            });\n\n            const credential = await navigator.credentials.get({\n                publicKey: signin.data,\n                mediation: 'autofill' in signinMethod ? \"conditional\" as CredentialMediationRequirement : undefined, // Typescript doesn't know about 'conditational' yet\n                signal: this.abortController.signal,\n            }) as PublicKeyCredential;\n\n            const response = await this.signinComplete(credential, signin.session);\n            return response;\n            \n        } catch (caughtError: any) {           \n            const errorMessage = getErrorMessage(caughtError);\n            const error = {\n                from: \"client\",\n                errorCode: \"unknown\",\n                title: errorMessage,\n            };\n            console.error(caughtError);\n            console.error(error);\n\n            return { error };\n        }\n    }\n\n    private async signinBegin(signinMethod: SigninMethod): PromiseResult<SigninBeginResponse> {\n        const response = await fetch(`${this.config.apiUrl}/signin/begin`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                userId: \"userId\" in signinMethod ? signinMethod.userId : undefined,\n                alias: \"alias\" in signinMethod ? signinMethod.alias : undefined,\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private async signinComplete(\n        credential: PublicKeyCredential,\n        session: string,\n    ): PromiseResult<TokenResponse> {\n        const assertionResponse = credential.response as AuthenticatorAssertionResponse;\n\n        const response = await fetch(`${this.config.apiUrl}/signin/complete`, {\n            method: 'POST',\n            headers: this.createHeaders(),\n            body: JSON.stringify({\n                session: session,\n                response: {\n                    id: credential.id,\n                    rawId: arrayBufferToBase64Url(new Uint8Array(credential.rawId)),\n                    type: credential.type,\n                    extensions: credential.getClientExtensionResults(),\n                    response: {\n                        authenticatorData: arrayBufferToBase64Url(\n                            assertionResponse.authenticatorData,\n                        ),\n                        clientDataJson: arrayBufferToBase64Url(\n                            assertionResponse.clientDataJSON\n                        ),\n                        signature: arrayBufferToBase64Url(\n                            assertionResponse.signature\n                        ),\n                    },\n                },\n                RPID: this.config.rpid,\n                Origin: this.config.origin,\n            }),\n        });\n\n        const res = await response.json();\n        if (response.ok) {\n            return res;\n        }\n\n        return { error: {...res, from: \"server\"}};\n    }\n\n    private handleAbort() {\n        this.abort();\n        this.abortController = new AbortController();\n    }\n\n    private assertBrowserSupported(): void {\n        if (!isBrowserSupported()) {\n            throw new Error('WebAuthn and PublicKeyCredentials are not supported on this browser/device');\n        }\n    }\n\n    private createHeaders(): Record<string, string> {\n        return {\n            ApiKey: this.config.apiKey,\n            'Content-Type': 'application/json',\n            'Client-Version': 'js-1.1.0'\n        };\n    }\n}\n\nexport async function isPlatformSupported(): Promise<boolean> {\n    if (!isBrowserSupported()) return false;\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport function isBrowserSupported(): boolean {\n    return window.PublicKeyCredential !== undefined && typeof window.PublicKeyCredential === 'function';\n}\n\nexport async function isAutofillSupported(): Promise<boolean> {\n    const PublicKeyCredential = window.PublicKeyCredential as any; // Typescript lacks support for this\n    if (!PublicKeyCredential.isConditionalMediationAvailable) return false;\n    return PublicKeyCredential.isConditionalMediationAvailable() as Promise<boolean>;\n}\n\nfunction base64ToBase64Url(base64: string): string {\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=*$/g, '');\n}\n\nfunction base64UrlToBase64(base64Url: string): string {\n    return base64Url.replace(/-/g, '+').replace(/_/g, '/');\n}\n\nfunction base64UrlToArrayBuffer(base64UrlString: string | BufferSource): ArrayBuffer {\n    // improvement: Remove BufferSource-type and add proper types upstream\n    if (typeof base64UrlString !== 'string') {\n        const msg = \"Cannot convert from Base64Url to ArrayBuffer: Input was not of type string\";\n        console.error(msg, base64UrlString);\n        throw new TypeError(msg);\n    }\n\n    const base64Unpadded = base64UrlToBase64(base64UrlString);\n    const paddingNeeded = (4 - (base64Unpadded.length % 4)) % 4;\n    const base64Padded = base64Unpadded.padEnd(base64Unpadded.length + paddingNeeded, \"=\");\n\n    const binary = window.atob(base64Padded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n\n    return bytes;\n}\n\nfunction arrayBufferToBase64Url(buffer: ArrayBuffer | Uint8Array): string {\n    const uint8Array = (() => {\n        if (Array.isArray(buffer)) return Uint8Array.from(buffer);\n        if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);\n        if (buffer instanceof Uint8Array) return buffer;\n\n        const msg = \"Cannot convert from ArrayBuffer to Base64Url. Input was not of type ArrayBuffer, Uint8Array or Array\";\n        console.error(msg, buffer);\n        throw new Error(msg);\n    })();\n\n    let string = '';\n    for (let i = 0; i < uint8Array.byteLength; i++) {\n        string += String.fromCharCode(uint8Array[i]);\n    }\n\n    const base64String = window.btoa(string);\n    return base64ToBase64Url(base64String);\n}\n\ntype ErrorWithMessage = {\n    message: string\n}\n\nfunction isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n    return (\n        typeof error === 'object' &&\n        error !== null &&\n        'message' in error &&\n        typeof (error as Record<string, unknown>).message === 'string'\n    )\n}\n\nfunction toErrorWithMessage(maybeError: unknown): ErrorWithMessage {\n    if (isErrorWithMessage(maybeError)) return maybeError\n\n    try {\n        return new Error(JSON.stringify(maybeError))\n    } catch {\n        // fallback in case there's an error stringifying the maybeError\n        // like with circular references for example.\n        return new Error(String(maybeError))\n    }\n}\n\nfunction getErrorMessage(error: unknown) {\n    return toErrorWithMessage(error).message\n}"],"names":[],"mappings":"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"}